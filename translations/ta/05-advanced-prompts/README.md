<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b2651fb16bcfbc62b8e518751ed90fdb",
  "translation_date": "2025-10-18T02:34:26+00:00",
  "source_file": "05-advanced-prompts/README.md",
  "language_code": "ta"
}
-->
# மேம்பட்ட ப்ராம்ப்ட்களை உருவாக்குதல்

[![மேம்பட்ட ப்ராம்ப்ட்களை உருவாக்குதல்](../../../translated_images/05-lesson-banner.522610fd4a2cd82dbed66bb7e6fe104ed6da172e085dbb4d9100b28dc73ed435.ta.png)](https://youtu.be/BAjzkaCdRok?si=NmUIyRf7-cDgbjtt)

முந்தைய அத்தியாயத்தில் கற்றுக்கொண்டவற்றை மீண்டும் நினைவூட்டுவோம்:

> ப்ராம்ப்ட் _என்ஜினியரிங்_ என்பது **மாதிரியை அதிக பொருத்தமான பதில்களுக்கு வழிநடத்த** பயனுள்ள வழிமுறைகள் அல்லது சூழல்களை வழங்குவதன் மூலம் செய்யப்படும் செயல்முறை.

ப்ராம்ப்ட்களை எழுதுவதற்கு இரண்டு படிகள் உள்ளன: ப்ராம்ப்ட்டை உருவாக்குதல், பொருத்தமான சூழல்களை வழங்குதல் மற்றும் _அப்டிமைசேஷன்_, ப்ராம்ப்ட்டை படிப்படியாக மேம்படுத்துவது.

இந்த நேரத்தில், ப்ராம்ப்ட்களை எப்படி எழுதுவது என்பது பற்றிய அடிப்படை புரிதலை நாங்கள் பெற்றுள்ளோம், ஆனால் மேலும் ஆழமாக செல்ல வேண்டும். இந்த அத்தியாயத்தில், நீங்கள் பல்வேறு ப்ராம்ப்ட்களை முயற்சிப்பதிலிருந்து, ஏன் ஒரு ப்ராம்ப்ட் மற்றொன்றை விட சிறந்தது என்பதை புரிந்துகொள்வதற்கு செல்லுவீர்கள். எந்த LLM-க்கும் பொருந்தக்கூடிய சில அடிப்படை தொழில்நுட்பங்களை பின்பற்றுவதன் மூலம் ப்ராம்ப்ட்களை உருவாக்குவது எப்படி என்பதை நீங்கள் கற்றுக்கொள்வீர்கள்.

## அறிமுகம்

இந்த அத்தியாயத்தில், நாம் பின்வரும் தலைப்புகளை கையாளுவோம்:

- ப்ராம்ப்ட் என்ஜினியரிங்கில் உங்கள் அறிவை விரிவாக்கி, உங்கள் ப்ராம்ப்ட்களில் பல்வேறு தொழில்நுட்பங்களைப் பயன்படுத்துதல்.
- உங்கள் ப்ராம்ப்ட்களை உருவாக்கி, வெளியீட்டை மாறுபடுத்துதல்.

## கற்றல் இலக்குகள்

இந்த பாடத்தை முடித்த பிறகு, நீங்கள்:

- உங்கள் ப்ராம்ப்ட்களின் முடிவுகளை மேம்படுத்தும் ப்ராம்ப்ட் என்ஜினியரிங் தொழில்நுட்பங்களைப் பயன்படுத்த முடியும்.
- மாறுபட்ட அல்லது தீர்மானமான ப்ராம்ப்ட்டிங் செய்ய முடியும்.

## ப்ராம்ப்ட் என்ஜினியரிங்

ப்ராம்ப்ட் என்ஜினியரிங் என்பது விரும்பிய முடிவை உருவாக்கும் ப்ராம்ப்ட்களை உருவாக்கும் செயல்முறையாகும். ப்ராம்ப்ட் என்ஜினியரிங்கில் ஒரு உரை ப்ராம்ப்ட்டை எழுதுவதற்கும் மேலானது பல உள்ளது. ப்ராம்ப்ட் என்ஜினியரிங் என்பது ஒரு பொறியியல் துறை அல்ல, இது விரும்பிய முடிவை பெற நீங்கள் பயன்படுத்தக்கூடிய தொழில்நுட்பங்களின் தொகுப்பாகும்.

### ப்ராம்ப்ட்டின் ஒரு எடுத்துக்காட்டு

இங்கே ஒரு அடிப்படை ப்ராம்ப்ட் உள்ளது:

> புவியியல் தொடர்பான 10 கேள்விகளை உருவாக்கவும்.

இந்த ப்ராம்ப்ட்டில், நீங்கள் பல்வேறு ப்ராம்ப்ட் தொழில்நுட்பங்களைப் பயன்படுத்துகிறீர்கள்.

இதனைப் பிரித்து பார்ப்போம்.

- **சூழல்**, இது "புவியியல்" பற்றி இருக்க வேண்டும் என்று நீங்கள் குறிப்பிடுகிறீர்கள்.
- **வெளியீட்டை வரையறுத்தல்**, நீங்கள் 10 கேள்விகளுக்கு மேல் வேண்டாம் என்று கூறுகிறீர்கள்.

### எளிய ப்ராம்ப்ட்டிங் குறைபாடுகள்

நீங்கள் விரும்பிய முடிவை பெறலாம் அல்லது பெற முடியாது. உங்கள் கேள்விகள் உருவாக்கப்படும், ஆனால் புவியியல் என்பது ஒரு பெரிய தலைப்பு, மேலும் நீங்கள் நாடுகள், தலைநகரங்கள், ஆறுகள் போன்றவற்றைப் பெறுவீர்களா என்பதை நீங்கள் அறிய முடியாது.

- **பெரிய தலைப்பு**, இது நாடுகள், தலைநகரங்கள், ஆறுகள் போன்றவற்றைப் பற்றியதா என்பதை நீங்கள் அறிய முடியாது.
- **வடிவம்**, நீங்கள் கேள்விகளை ஒரு குறிப்பிட்ட வடிவத்தில் உருவாக்க விரும்பினால் என்ன?

ப்ராம்ப்ட்களை உருவாக்கும்போது கவனிக்க வேண்டிய பல விஷயங்கள் உள்ளன என்பதை நீங்கள் காணலாம்.

இப்போது வரை, நாம் ஒரு எளிய ப்ராம்ப்ட் எடுத்துக்காட்டைப் பார்த்துள்ளோம், ஆனால் ஜெனரேட்டிவ் AI பல்வேறு பங்கு மற்றும் துறைகளில் உள்ள மக்களுக்கு உதவுவதற்கான பலவற்றை செய்ய முடியும். அடுத்ததாக சில அடிப்படை தொழில்நுட்பங்களை ஆராய்வோம்.

### ப்ராம்ப்ட்டிங் தொழில்நுட்பங்கள்

முதலில், ப்ராம்ப்ட்டிங் என்பது ஒரு LLM இன் _தோன்றும்_ பண்பாகும் என்பதை நாம் புரிந்துகொள்ள வேண்டும், இது மாதிரியில் உள்ள ஒரு அம்சமாக உருவாக்கப்படவில்லை, மாறாக மாதிரியைப் பயன்படுத்தும் போது நாம் கண்டுபிடிக்கிறோம்.

LLM ஐ ப்ராம்ப்ட் செய்ய சில அடிப்படை தொழில்நுட்பங்களை நாம் பயன்படுத்தலாம். அவற்றை ஆராய்வோம்.

- **Zero-shot prompting**, இது ப்ராம்ப்ட்டிங் செய்யும் அடிப்படை வடிவமாகும். இது LLM இன் பயிற்சி தரவின் அடிப்படையில் பதிலை கோரும் ஒரு ப்ராம்ப்ட் ஆகும்.
- **Few-shot prompting**, இந்த ப்ராம்ப்ட்டிங் வகை LLM ஐ வழிநடத்துவதற்காக 1 அல்லது அதற்கு மேற்பட்ட எடுத்துக்காட்டுகளை வழங்குகிறது.
- **Chain-of-thought**, இந்த ப்ராம்ப்ட்டிங் ஒரு பிரச்சினையை படிகளாக பிரிக்க LLM ஐ வழிநடத்துகிறது.
- **Generated knowledge**, ஒரு ப்ராம்ப்ட்டின் பதிலை மேம்படுத்த, நீங்கள் உங்கள் ப்ராம்ப்ட்டுடன் கூடுதலாக உருவாக்கப்பட்ட தகவல்களை வழங்கலாம்.
- **Least to most**, chain-of-thought போலவே, இந்த தொழில்நுட்பம் ஒரு பிரச்சினையை படிகளாக பிரித்து, அவற்றை வரிசையாக செய்யுமாறு கேட்கிறது.
- **Self-refine**, இந்த தொழில்நுட்பம் LLM இன் வெளியீட்டை விமர்சித்து, அதை மேம்படுத்துமாறு கேட்கிறது.
- **Maieutic prompting**, இங்கு நீங்கள் LLM பதில் சரியானது என்பதை உறுதிப்படுத்த விரும்புகிறீர்கள், மேலும் பதிலின் பல்வேறு பகுதிகளை விளக்குமாறு கேட்கிறீர்கள். இது ஒரு வகையான self-refine ஆகும்.

### Zero-shot prompting

இந்த ப்ராம்ப்ட்டிங் பாணி மிகவும் எளிமையானது, இது ஒரு ப்ராம்ப்ட்டை மட்டுமே கொண்டுள்ளது. இந்த தொழில்நுட்பம் நீங்கள் LLM களைப் பற்றி கற்றுக்கொள்வதைத் தொடங்கும்போது நீங்கள் பயன்படுத்தக்கூடியது. இதோ ஒரு எடுத்துக்காட்டு:

- ப்ராம்ப்ட்: "அல்ஜீப்ரா என்றால் என்ன?"
- பதில்: "அல்ஜீப்ரா என்பது கணிதத்தின் ஒரு கிளையாகும், இது கணிதச் சின்னங்கள் மற்றும் அவற்றை நடத்தும் விதிகளைப் படிக்கிறது."

### Few-shot prompting

இந்த ப்ராம்ப்ட்டிங் பாணி மாதிரிக்கு சில எடுத்துக்காட்டுகளை வழங்குவதன் மூலம் உதவுகிறது. இது ஒரு ப்ராம்ப்ட்டுடன் கூடுதல் பணிக்குறிப்புகளை கொண்டுள்ளது. இதோ ஒரு எடுத்துக்காட்டு:

- ப்ராம்ப்ட்: "ஷேக்ஸ்பியர் பாணியில் ஒரு கவிதையை எழுதுங்கள். இங்கே சில ஷேக்ஸ்பியர் சோனெட் எடுத்துக்காட்டுகள் உள்ளன:
  சோனெட் 18: 'நீ ஒரு கோடை நாளுடன் ஒப்பிடப்படுவாயா? நீ மிகவும் அழகானவளும் மிதமானவளும்...'
  சோனெட் 116: 'உண்மையான மனதின் திருமணத்திற்கு தடைகள் ஏற்படாது. காதல் என்பது மாற்றம் ஏற்படும் போது மாறுவது அல்ல...'
  சோனெட் 132: 'உன் கண்களை நான் காதலிக்கிறேன், அவை எனக்கு இரக்கமுடையவையாக இருக்கின்றன, உன் இதயத்தை அறிந்து என்னை வெறுத்து...'
  இப்போது, சந்திரனின் அழகைப் பற்றி ஒரு சோனெட்டை எழுதுங்கள்."
- பதில்: "வானில், சந்திரன் மெதுவாக பிரகாசிக்கிறது, வெள்ளை வெளிச்சத்தில் அதன் மென்மையான அழகை வீசுகிறது,..."

எடுத்துக்காட்டுகள் LLM க்கு விரும்பிய வெளியீட்டின் சூழல், வடிவம் அல்லது பாணியைப் புரிந்துகொள்ள உதவுகின்றன. அவை மாதிரிக்கு குறிப்பிட்ட பணியைப் புரிந்துகொள்ளவும், மேலும் துல்லியமான மற்றும் பொருத்தமான பதில்களை உருவாக்கவும் உதவுகின்றன.

### Chain-of-thought

Chain-of-thought என்பது மிகவும் சுவாரஸ்யமான தொழில்நுட்பமாகும், ஏனெனில் இது LLM ஐ பல படிகளின் மூலம் எடுத்துச் செல்லும். LLM ஐ எதையாவது செய்ய எப்படி புரிய வைக்க வேண்டும் என்பதற்கான யோசனையாகும். பின்வரும் எடுத்துக்காட்டைப் பரிசீலிக்கவும், chain-of-thought உடன் மற்றும் இல்லாமல்:

    - ப்ராம்ப்ட்: "அலிஸ் 5 ஆப்பிள்கள் வைத்திருக்கிறார், 3 ஆப்பிள்களை எறிகிறார், 2 ஆப்பிள்களை பாப் க்கு கொடுக்கிறார், பாப் ஒரு ஆப்பிளை திருப்பி கொடுக்கிறார், அலிஸிடம் எத்தனை ஆப்பிள்கள் உள்ளன?"
    - பதில்: 5

LLM பதிலளிக்கிறது 5, இது தவறானது. சரியான பதில் 1 ஆப்பிள், கணக்கீடு (5 -3 -2 + 1 = 1) அடிப்படையில்.

அதை சரியாக செய்ய LLM க்கு எப்படி கற்பிக்கலாம்?

Chain-of-thought ஐ முயற்சிப்போம். Chain-of-thought ஐப் பயன்படுத்துவது:

1. LLM க்கு ஒரு போன்ற எடுத்துக்காட்டை கொடுங்கள்.
1. கணக்கீட்டை காட்டவும், அதை சரியாக கணக்கிடுவது எப்படி என்பதை காட்டவும்.
1. அசல் ப்ராம்ப்ட்டை வழங்கவும்.

இதோ எப்படி:

- ப்ராம்ப்ட்: "லிசா 7 ஆப்பிள்கள் வைத்திருக்கிறார், 1 ஆப்பிளை எறிகிறார், 4 ஆப்பிள்களை பார்ட் க்கு கொடுக்கிறார், பார்ட் ஒரு ஆப்பிளை திருப்பி கொடுக்கிறார்:
  7 -1 = 6
  6 -4 = 2
  2 +1 = 3  
  அலிஸ் 5 ஆப்பிள்கள் வைத்திருக்கிறார், 3 ஆப்பிள்களை எறிகிறார், 2 ஆப்பிள்களை பாப் க்கு கொடுக்கிறார், பாப் ஒரு ஆப்பிளை திருப்பி கொடுக்கிறார், அலிஸிடம் எத்தனை ஆப்பிள்கள் உள்ளன?"
  பதில்: 1

நீங்கள் பார்க்கும் போது, chain-of-thought என்பது மிகவும் சக்திவாய்ந்த தொழில்நுட்பமாகும்.

### Generated knowledge

பல நேரங்களில், நீங்கள் ஒரு ப்ராம்ப்ட்டை உருவாக்க விரும்பும்போது, உங்கள் நிறுவனத்தின் தரவுகளைப் பயன்படுத்த விரும்புகிறீர்கள். ப்ராம்ப்ட்டின் ஒரு பகுதி நிறுவனத்திலிருந்து இருக்க வேண்டும், மற்ற பகுதி நீங்கள் ஆர்வமாக இருக்கும் ப்ராம்ப்ட்டாக இருக்க வேண்டும்.

உதாரணமாக, நீங்கள் காப்பீட்டு வணிகத்தில் இருந்தால், உங்கள் ப்ராம்ப்ட்டு இவ்வாறு இருக்கலாம்:

```text
{{company}}: {{company_name}}
{{products}}:
{{products_list}}
Please suggest an insurance given the following budget and requirements:
Budget: {{budget}}
Requirements: {{requirements}}
```

மேலே, ப்ராம்ப்ட்டு ஒரு டெம்ப்ளேட் பயன்படுத்தி உருவாக்கப்பட்டுள்ளதை நீங்கள் காணலாம். டெம்ப்ளேட்டில் `{{variable}}` எனக் குறிக்கப்பட்டுள்ள பல மாறிகள் உள்ளன, அவை நிறுவனத்தின் API இல் இருந்து உண்மையான மதிப்புகளால் மாற்றப்படும்.

மாறிகள் நிறுவனத்தின் உள்ளடக்கத்தால் மாற்றப்பட்ட பிறகு ப்ராம்ப்ட்டு எப்படி இருக்கும் என்பதைப் பார்ப்போம்:

```text
Insurance company: ACME Insurance
Insurance products (cost per month):
- Car, cheap, 500 USD
- Car, expensive, 1100 USD
- Home, cheap, 600 USD
- Home, expensive, 1200 USD
- Life, cheap, 100 USD

Please suggest an insurance given the following budget and requirements:
Budget: $1000
Requirements: Car, Home, and Life insurance
```

இந்த ப்ராம்ப்ட்டை ஒரு LLM வழியாக இயக்குவது இந்த பதிலை உருவாக்கும்:

```output
Given the budget and requirements, we suggest the following insurance package from ACME Insurance:
- Car, cheap, 500 USD
- Home, cheap, 600 USD
- Life, cheap, 100 USD
Total cost: $1,200 USD
```

நீங்கள் காணும் போது, இது Life insurance ஐ பரிந்துரைக்கிறது, இது செய்யக்கூடாது. இந்த முடிவு, ப்ராம்ப்ட்டை தெளிவாக மாற்ற வேண்டும் என்பதற்கான ஒரு அறிகுறியாகும். சில _trial and error_ களின் பிறகு, நாங்கள் பின்வரும் ப்ராம்ப்ட்டை உருவாக்குகிறோம்:

```text
Insurance company: ACME Insurance
Insurance products (cost per month):
- type: Car, cheap, cost: 500 USD
- type: Car, expensive, cost: 1100 USD
- type: Home, cheap, cost: 600 USD
- type: Home, expensive, cost: 1200 USD
- type: Life, cheap, cost: 100 USD

Please suggest an insurance given the following budget and requirements:
Budget: $1000 restrict choice to types: Car, Home
```

_type_ மற்றும் _cost_ ஐச் சேர்த்தது மற்றும் _restrict_ என்ற முக்கிய வார்த்தையைப் பயன்படுத்துவது LLM க்கு நாம் என்ன விரும்புகிறோம் என்பதைப் புரிந்துகொள்ள உதவுகிறது.

இப்போது, நாங்கள் பின்வரும் பதிலைப் பெறுகிறோம்:

```output
Given the budget and requirements, we suggest the Car, Cheap insurance product which costs 500 USD per month.
```

இந்த எடுத்துக்காட்டின் நோக்கம், _generated knowledge_ போன்ற அடிப்படை தொழில்நுட்பத்தைப் பயன்படுத்தினாலும், பெரும்பாலான சந்தர்ப்பங்களில் விரும்பிய முடிவை பெற ப்ராம்ப்ட்டை அப்டிமைஸ் செய்ய வேண்டும் என்பதை காட்டுவதாகும்.

### Least-to-most

Least-to-most prompting யின் யோசனை, ஒரு பெரிய பிரச்சினையை துணை பிரச்சினைகளாக பிரிப்பது. இவ்வாறு, நீங்கள் LLM ஐ பெரிய பிரச்சினையை "வெற்றி பெற" எப்படி வழிநடத்துவது என்பதை உதவுகிறீர்கள். ஒரு நல்ல எடுத்துக்காட்டு தரவியல் அறிவியல் தொடர்பானது, நீங்கள் LLM க்கு இவ்வாறு பிரிக்கக் கேட்கலாம்:

> ப்ராம்ப்ட்: தரவியல் அறிவியலை 5 படிகளில் எப்படி செய்யலாம்?

உங்கள் AI உதவியாளர் இதற்கு பதிலளிக்க:

1. தரவுகளை சேகரிக்கவும்
1. தரவுகளை சுத்தம் செய்யவும்
1. தரவுகளை பகுப்பாய்வு செய்யவும்
1. தரவுகளை வரைபடமாக்கவும்
1. தரவுகளை வழங்கவும்

### Self-refine, முடிவுகளை விமர்சிக்கவும்

ஜெனரேட்டிவ் AI கள் மற்றும் LLM களுடன், வெளியீட்டை நம்ப முடியாது. நீங்கள் அதை சரிபார்க்க வேண்டும். இறுதியில், LLM உங்களுக்கு அடுத்ததாக சொல்ல வேண்டியதை மட்டுமே வழங்குகிறது, சரியானதை அல்ல. எனவே, LLM ஐ தானாகவே விமர்சிக்குமாறு கேட்பது நல்ல யோசனை, இது self-refine தொழில்நுட்பத்திற்கு வழிவகுக்கிறது.

இது செயல்படுவது எப்படி என்றால், நீங்கள் பின்வரும் படிகளைப் பின்பற்ற வேண்டும்:

1. LLM க்கு ஒரு பிரச்சினையை தீர்க்க ஆரம்ப ப்ராம்ப்ட்டை கேட்கவும்
1. LLM பதிலளிக்கிறது
1. நீங்கள் பதிலை விமர்சித்து AI ஐ மேம்படுத்துமாறு கேட்கவும்
1. LLM மீண்டும் பதிலளிக்கிறது, இந்த முறை விமர்சனத்தைப் பரிசீலித்து, அது கண்டுபிடித்த தீர்வுகளை முன்மொழிகிறது

இந்த செயல்முறையை நீங்கள் விரும்பிய அளவுக்கு பல முறை மீண்டும் செய்யலாம்.

இந்த தொழில்நுட்பத்தைப் பயன்படுத்தி ஒரு எடுத்துக்காட்டு இங்கே:

> ப்ராம்ப்ட்: "products மற்றும் customers எனும் வழிகளை கொண்ட ஒரு Python Web API ஐ உருவாக்கவும்"

AI பதில்:

```python
import flask
app = Flask(__name__)

@app.route('/products')
def products():
    return 'Products'

@app.route('/customers')
def customers():
    return 'Customers'
```

> ப்ராம்ப்ட்: மேலே உள்ள குறியீட்டின் 3 மேம்பாடுகளை பரிந்துரைக்கவும்

AI பதில்:

```text
Sure, here are three suggestions to improve the code:

Import the correct module: The first line should import Flask instead of flask. The correct import statement should be from flask import Flask.

Add a main function: Add a if __name__ == '__main__': block to the end of the file to run the application when the file is executed.

Use f-strings: Use f-strings to format the return statements in the route functions. For example, return 'Products' can be changed to return f'This is the {request.path} page'.
```

```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/products')
def products():
    return f'This is the {request.path} page'

@app.route('/customers')
def customers():
    return f'This is the {request.path} page'

if __name__ == '__main__':
    app.run()
```

நீங்கள் காணும் போது, முதல் பரிந்துரைக்கப்பட்ட குறியீட்டை மேம்படுத்துவதற்கு மேலே உள்ள AI பதில், முதல் பதிலை விமர்சிப்பதன் மூலம் மேம்படுத்துகிறது.

### Maieutic prompting

Maieutic prompting என்பது self-refine உடன் ஒத்ததாகும், ஆனால் இது LLM ஐ தன்னை விளக்குமாறு கேட்பது பற்றியது. LLM இன் வெளியீட்டில் முரண்பாடுகளை குறைக்க, சரியான பதிலை உறுதிப்படுத்துவது இதன் நோக்கம். பின்வரும் செயல்முறையை பின்பற்றவும்:

1. LLM க்கு ஒரு கேள்வியை பதிலளிக்கக் கேட்கவும்
1. பதிலின் ஒவ்வொரு பகுதிக்கும், LLM ஐ மேலும் விரிவாக விளக்குமாறு கேட்கவும்.
1. முரண்பாடுகள் இருந்தால், முரண்பாடான பகுதிகளை நிராகரிக்கவும்.

ஒவ்வொரு பகுதிக்கும் 2 மற்றும் 3 ஐ மீண்டும் செய்யவும், நீங்கள் பதிலில் திருப்தி அடையும் வரை.

இங்கே ஒரு எடுத்துக்காட்டு ப்ராம்ப்ட்:

> ப்ராம்ப்ட்: ஒரு தொற்றுநோயைத் தடுக்க ஒரு நெருக்கடி திட்டத்தை 5 படிகளில் எப்படி உருவாக்கலாம்?
> LLM பதில்:

```text
1. Identify the risks
1. Identify the stakeholders
1. Identify the resources
1. Identify the actions
1. Identify the communication channels
```

இது 5 படிகளை அடையாளம் காட்டியுள்ளது, ஆனால் இது சரியானதா என்பதை நாங்கள் தீர்மானிக்க முடியுமா? LLM ஐ ஒவ்வொரு படியையும் மேலும் விரிவாக விளக்குமாறு கேட்போம்:

> ப்ராம்ப்ட்: முதல் படியை மேலும் விரிவாக விளக்கவும், தொற்றுநோயுடன் தொடர்புடைய அபாயங்கள் என்ன?

```text
The risks are the following:

- Loss of life
- Loss of business
- Loss of reputation
- Loss of customers
- Loss of employees
```

இந்த நேரத்தில், LLM சரியானதா என்பதை உறுதிப்படுத்த, முதல் அபாயத்தை மேலும் விரிவாக விளக்குமாறு கேட்கலாம், மேலும் மேலே உள்ள பதிலுடன் இது முரண்படாதது என்று நம்பலாம்:

> ப்ராம்ப்ட்: தொற்றுநோயில், மிகப்பெரிய அபாயம் எது, ஏன்?

```text
The biggest risk is loss of life because it's the most important thing to protect.
```

> தொற்றுநோயில் இரண்டு மிகப்பெரிய அபாயங்கள் என்ன?

```text
The two biggest risks are loss of life and loss of business.
```

இந்த நேரத்தில், LLM "வாழ்க்கை" மற்றும் "வணிகம்" ஆகியவற்றை முக்கியமான இரண்டு அபாயங்களாக குறிப்பிடுகிறது. இப்போது நாங்கள் அடுத்த படிக்குச் செல்லலாம் மற்றும் பதிலில் நம்பகத்தன்மை உள்ளது என்று உணரலாம். இருப்பினும், LLM ஐ அசலாக நம்பக்கூடாது, வெளியீட்டை எப்போதும் சரிபார்க்க வேண்டும்.

## உங்கள் வெளியீட்டை மாறுபடுத்துங்கள்

LLM கள் இயல்பாக தீர்மானமற்றவை, அதாவது நீங்கள் ஒரே ப்ராம்ப்ட்டை இயக்கும் ஒவ்வொரு முறையும் வெவ்வேறு முடிவுகளைப் பெறுவீர்கள். உத
பார்க்கும் போது, முடிவுகள் மிகவும் மாறுபட்டதாக இருக்கின்றன.

> கவனிக்கவும், மேலும் பல அளவுருக்களை மாற்றி வெளியீட்டை மாறுபடுத்தலாம், உதாரணமாக top-k, top-p, repetition penalty, length penalty மற்றும் diversity penalty, ஆனால் இவை இந்த பாடத்திட்டத்தின் வரம்புக்கு வெளியே உள்ளவை.

## நல்ல நடைமுறைகள்

நீங்கள் விரும்பும் முடிவுகளை பெற பல நடைமுறைகளை பயன்படுத்தலாம். நீங்கள் prompting ஐ அதிகமாக பயன்படுத்தும் போது உங்கள் சொந்த பாணியை கண்டுபிடிப்பீர்கள்.

நாம் கற்றுக்கொண்ட தொழில்நுட்பங்களுக்கு கூடுதலாக, LLM ஐ prompting செய்யும்போது சில நல்ல நடைமுறைகளை கவனிக்க வேண்டும்.

இங்கே சில நல்ல நடைமுறைகள் உள்ளன:

- **சூழலை குறிப்பிடவும்**. சூழல் முக்கியம், நீங்கள் குறிப்பிட்ட அளவுக்கு அதிகமாக கூறினால், உதாரணமாக துறை, தலைப்பு போன்றவை, முடிவுகள் சிறப்பாக இருக்கும்.
- வெளியீட்டை வரையறுக்கவும். நீங்கள் குறிப்பிட்ட எண்ணிக்கையிலான உருப்படிகள் அல்லது குறிப்பிட்ட நீளம் வேண்டும் என்றால், அதை குறிப்பிடவும்.
- **எது மற்றும் எப்படி என்பதை குறிப்பிடவும்**. நீங்கள் என்ன வேண்டும் மற்றும் அதை எப்படி வேண்டும் என்பதை குறிப்பிடுவது முக்கியம், உதாரணமாக "Python Web API ஐ உருவாக்கவும், இதில் products மற்றும் customers என்ற இரண்டு வழிகள் இருக்க வேண்டும், அதை 3 கோப்புகளாக பிரிக்கவும்".
- **டெம்ப்ளேட்களை பயன்படுத்தவும்**. பெரும்பாலும், உங்கள் நிறுவனத்தின் தரவுடன் உங்கள் prompts ஐ செறிவூட்ட விரும்புவீர்கள். இதற்கு டெம்ப்ளேட்களை பயன்படுத்தவும். டெம்ப்ளேட்களில் நீங்கள் உண்மையான தரவுடன் மாற்றக்கூடிய மாறிகள் இருக்கலாம்.
- **சரியாக எழுத்துப்பிழை இல்லாமல் எழுதவும்**. LLMs உங்களுக்கு சரியான பதிலை வழங்கலாம், ஆனால் நீங்கள் சரியாக எழுதினால், நீங்கள் சிறந்த பதிலை பெறுவீர்கள்.

## பணிக்கட்டளை

இங்கே Flask ஐ பயன்படுத்தி எளிய API ஐ உருவாக்க Python கோடு உள்ளது:

```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/')
def hello():
    name = request.args.get('name', 'World')
    return f'Hello, {name}!'

if __name__ == '__main__':
    app.run()
```

GitHub Copilot அல்லது ChatGPT போன்ற AI உதவியாளரை பயன்படுத்தி "self-refine" தொழில்நுட்பத்தை பயன்படுத்தி கோட்டை மேம்படுத்தவும்.

## தீர்வு

கோட்டிற்கு பொருத்தமான prompts ஐ சேர்த்து பணிக்கட்டளையை தீர்க்க முயற்சிக்கவும்.

> [!TIP]
> மேம்படுத்துமாறு கேட்க ஒரு prompt ஐ உருவாக்கவும், எத்தனை மேம்பாடுகள் செய்ய வேண்டும் என்பதை வரையறுக்கவும். மேலும், குறிப்பிட்ட வழியில் மேம்படுத்துமாறு கேட்கவும், உதாரணமாக கட்டமைப்பு, செயல்திறன், பாதுகாப்பு போன்றவை.

[தீர்வு](../../../05-advanced-prompts/python/aoai-solution.py)

## அறிவு சரிபார்ப்பு

நான் ஏன் chain-of-thought prompting ஐ பயன்படுத்த வேண்டும்? 1 சரியான பதில் மற்றும் 2 தவறான பதில்களை காட்டவும்.

1. LLM ஐ ஒரு பிரச்சினையை எப்படி தீர்க்க வேண்டும் என்று கற்பிக்க.
1. B, LLM ஐ கோட்டில் உள்ள பிழைகளை கண்டுபிடிக்க கற்பிக்க.
1. C, LLM ஐ பல்வேறு தீர்வுகளை உருவாக்குமாறு உத்தரவிட.

A: 1, ஏனெனில் chain-of-thought என்பது LLM ஐ ஒரு பிரச்சினையை தீர்க்க எப்படி என்று கற்பிக்க, அதற்கான படிகள் மற்றும் இதே போன்ற பிரச்சினைகள் எப்படி தீர்க்கப்பட்டன என்பதை வழங்குவது.

## 🚀 சவால்

நீங்கள் பணிக்கட்டளையில் self-refine தொழில்நுட்பத்தை பயன்படுத்தியுள்ளீர்கள். நீங்கள் உருவாக்கிய எந்த ஒரு நிரலையும் எடுத்துக்கொண்டு அதில் நீங்கள் செய்ய விரும்பும் மேம்பாடுகளை பரிசீலிக்கவும். இப்போது self-refine தொழில்நுட்பத்தை பயன்படுத்தி பரிந்துரைக்கப்பட்ட மாற்றங்களைச் செய்யவும். முடிவுகள் எப்படி இருந்தன, சிறந்ததா அல்லது மோசமா?

## சிறந்த வேலை! உங்கள் கற்றலை தொடருங்கள்

இந்த பாடத்தை முடித்த பிறகு, [Generative AI Learning collection](https://aka.ms/genai-collection?WT.mc_id=academic-105485-koreyst) ஐ பாருங்கள், Generative AI அறிவை மேம்படுத்த தொடர்ந்து கற்றுக்கொள்ளுங்கள்!

Lesson 6 க்கு செல்லுங்கள், அங்கு Prompt Engineering பற்றிய அறிவை பயன்படுத்தி [text generation apps உருவாக்குவோம்](../06-text-generation-apps/README.md?WT.mc_id=academic-105485-koreyst)

---

**புறக்குறிப்பு**:  
இந்த ஆவணம் AI மொழிபெயர்ப்பு சேவை [Co-op Translator](https://github.com/Azure/co-op-translator) பயன்படுத்தி மொழிபெயர்க்கப்பட்டுள்ளது. நாங்கள் துல்லியத்திற்காக முயற்சிக்கிறோம், ஆனால் தானியங்கி மொழிபெயர்ப்புகளில் பிழைகள் அல்லது தவறுகள் இருக்கக்கூடும் என்பதை கவனத்தில் கொள்ளவும். அதன் தாய்மொழியில் உள்ள அசல் ஆவணம் அதிகாரப்பூர்வ ஆதாரமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பைப் பயன்படுத்துவதால் ஏற்படும் எந்த தவறான புரிதல்கள் அல்லது தவறான விளக்கங்களுக்கு நாங்கள் பொறுப்பல்ல.