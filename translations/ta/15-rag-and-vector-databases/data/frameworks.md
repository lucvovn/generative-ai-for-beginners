<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b5466bcedc3c75aa35476270362f626a",
  "translation_date": "2025-10-11T11:15:42+00:00",
  "source_file": "15-rag-and-vector-databases/data/frameworks.md",
  "language_code": "ta"
}
-->
# நர்வியல் நெட்வொர்க் கட்டமைப்புகள்

நாம் ஏற்கனவே கற்றுக்கொண்டது போல, நர்வியல் நெட்வொர்க்களை திறமையாக பயிற்சி செய்ய இரண்டு முக்கியமான செயல்களை செய்ய வேண்டும்:

* டென்சர்களில் செயல்பட வேண்டும், உதாரணமாக பெருக்கம், கூட்டல் மற்றும் சில செயல்பாடுகளை (sigmoid அல்லது softmax போன்றவை) கணக்கிட வேண்டும்.
* அனைத்து வெளிப்பாடுகளின் சார்புகளை (gradients) கணக்கிட வேண்டும்,_gradient descent optimization_ செய்ய.

`numpy` நூலகம் முதல் செயல்பாட்டை செய்ய முடியும், ஆனால் சார்புகளை கணக்கிட ஒரு முறைமையை தேவைப்படும். முந்தைய பகுதியில் நாம் உருவாக்கிய கட்டமைப்பில், `backward` முறைமையில் அனைத்து சார்ப செயல்பாடுகளையும் கையால் நிரலிட வேண்டியிருந்தது, இது _backpropagation_ செய்கிறது. ஒரு சிறந்த கட்டமைப்பு *எந்த வெளிப்பாடுகளின்* சார்புகளை கணக்கிடும் வாய்ப்பை வழங்க வேண்டும்.

மற்றொரு முக்கியமான விஷயம் GPU அல்லது TPU போன்ற சிறப்பு கணினி அலகுகளில் கணக்கீடுகளை செய்ய வேண்டும். ஆழமான நர்வியல் நெட்வொர்க் பயிற்சி *மிக அதிக* கணக்கீடுகளை தேவைப்படும், மற்றும் GPU-க்களில் அவற்றை இணைந்து செயல்படுத்துவது மிகவும் முக்கியம்.

> ✅ 'parallelize' என்ற சொல் கணக்கீடுகளை பல சாதனங்களில் பகிர்ந்து செயல்படுத்துவதை குறிக்கிறது.

தற்போது, மிகவும் பிரபலமான நர்வியல் கட்டமைப்புகள்: TensorFlow மற்றும் PyTorch. இரண்டும் CPU மற்றும் GPU-இல் டென்சர்களுடன் செயல்பட ஒரு குறைந்த-நிலை API-ஐ வழங்குகின்றன. குறைந்த-நிலை API-க்கு மேலாக, Keras மற்றும் PyTorch Lightning எனப்படும் உயர்-நிலை API-களும் உள்ளன.

குறைந்த-நிலை API | TensorFlow | PyTorch  
--------------|-------------------------------------|--------------------------------  
உயர்-நிலை API | Keras | PyTorch Lightning  

**குறைந்த-நிலை API-கள்** இரண்டிலும் **கணக்கீட்டு வரைபடங்களை** உருவாக்க அனுமதிக்கின்றன. இந்த வரைபடம் கொடுக்கப்பட்ட உள்ளீட்டு அளவுருக்களுடன் வெளியீட்டை (சாதாரணமாக இழப்பு செயல்பாடு) கணக்கிட எப்படி என்பதை வரையறுக்கிறது, மற்றும் GPU-இல் கணக்கீடுக்கு அனுப்பப்படலாம், அது கிடைத்தால். இந்த கணக்கீட்டு வரைபடத்தை வேறுபடுத்தி சார்புகளை கணக்கிடும் செயல்பாடுகள் உள்ளன, அவற்றை மாடல் அளவுருக்களை மேம்படுத்த பயன்படுத்தலாம்.

**உயர்-நிலை API-கள்** நர்வியல் நெட்வொர்க்களை **அடுக்கு வரிசையாக** கருதுகின்றன, மற்றும் பெரும்பாலான நர்வியல் நெட்வொர்க்களை உருவாக்க மிகவும் எளிதாக்குகின்றன. மாடலை பயிற்சி செய்ய பொதுவாக தரவுகளை தயாரித்து, `fit` செயல்பாட்டை அழைப்பதன் மூலம் வேலை செய்யலாம்.

உயர்-நிலை API-கள் வழக்கமான நர்வியல் நெட்வொர்க்களை விரைவாக உருவாக்க அனுமதிக்கின்றன, மேலும் பல விவரங்களை கவலைப்படாமல் இருக்கலாம். அதே நேரத்தில், குறைந்த-நிலை API-கள் பயிற்சி செயல்முறையில் அதிக கட்டுப்பாட்டை வழங்குகின்றன, எனவே புதிய நர்வியல் நெட்வொர்க் கட்டமைப்புகளுடன் நீங்கள் வேலை செய்யும் போது ஆராய்ச்சியில் அதிகமாக பயன்படுத்தப்படுகின்றன.

இரண்டு API-களையும் ஒன்றாக பயன்படுத்த முடியும் என்பதை புரிந்துகொள்வது முக்கியம், உதாரணமாக, நீங்கள் குறைந்த-நிலை API-யை பயன்படுத்தி உங்கள் சொந்த நெட்வொர்க் அடுக்கு கட்டமைப்பை உருவாக்கலாம், பின்னர் அதை உயர்-நிலை API-யை பயன்படுத்தி உருவாக்கப்பட்ட மற்றும் பயிற்சி செய்யப்பட்ட பெரிய நெட்வொர்க்கில் பயன்படுத்தலாம். அல்லது நீங்கள் அடுக்குகளின் வரிசையாக உயர்-நிலை API-யை பயன்படுத்தி ஒரு நெட்வொர்க்கை வரையறுக்கலாம், பின்னர் உங்கள் சொந்த குறைந்த-நிலை பயிற்சி மடக்கத்தை பயன்படுத்தி மேம்படுத்தல் செய்யலாம். இரண்டு API-களும் ஒரே அடிப்படை அடிப்படையில் செயல்படுகின்றன, மற்றும் ஒன்றாக நன்றாக வேலை செய்ய வடிவமைக்கப்பட்டுள்ளன.

## கற்றல்

இந்த பாடத்தில், PyTorch மற்றும் TensorFlow இரண்டிற்கும் உள்ளடக்கத்தை வழங்குகிறோம். நீங்கள் விரும்பிய கட்டமைப்பை தேர்வு செய்து, அதற்கான நோட்புக்குகளை மட்டும் படிக்கலாம். எந்த கட்டமைப்பை தேர்வு செய்வது என்று உறுதியாக இல்லையெனில், **PyTorch vs. TensorFlow** பற்றிய இணைய விவாதங்களை படிக்கவும். மேலும், இரண்டு கட்டமைப்புகளையும் பார்வையிட்டு சிறந்த புரிதலை பெறலாம்.

சாத்தியமான இடங்களில், எளிமைக்காக உயர்-நிலை API-களை பயன்படுத்துவோம். ஆனால், நர்வியல் நெட்வொர்க்கள் அடிப்படையில் எப்படி வேலை செய்கின்றன என்பதை புரிந்துகொள்வது முக்கியம், எனவே ஆரம்பத்தில் குறைந்த-நிலை API மற்றும் டென்சர்களுடன் வேலை செய்வதன் மூலம் தொடங்குகிறோம். ஆனால், நீங்கள் விரைவாக தொடங்க விரும்பினால் மற்றும் இந்த விவரங்களை கற்றல் மீது அதிக நேரம் செலவிட விரும்பவில்லை என்றால், அவற்றை தவிர்த்து, நேரடியாக உயர்-நிலை API நோட்புக்குகளுக்கு செல்லலாம்.

## ✍️ பயிற்சிகள்: கட்டமைப்புகள்

தொடர்ந்து கற்றல் செய்ய கீழே உள்ள நோட்புக்குகளை பயன்படுத்தவும்:

குறைந்த-நிலை API | TensorFlow+Keras நோட்புக் | PyTorch  
--------------|-------------------------------------|--------------------------------  
உயர்-நிலை API | Keras | *PyTorch Lightning*  

கட்டமைப்புகளை கற்றுக்கொண்ட பிறகு, overfitting பற்றிய கருத்தை மீண்டும் பாருங்கள்.

# Overfitting

Overfitting என்பது இயந்திர கற்றலில் மிகவும் முக்கியமான கருத்தாகும், மற்றும் அதை சரியாக புரிந்துகொள்வது மிகவும் முக்கியம்!

கீழே உள்ள 5 புள்ளிகளை (கிராஃப்களில் `x` மூலம் பிரதிநிதித்துவம் செய்யப்படும்) அணுகுவதற்கான பிரச்சினையை கவனியுங்கள்:

!linear | overfit  
-------------------------|--------------------------  
**நேர்மையான மாடல், 2 அளவுருக்கள்** | **நேர்மற்ற மாடல், 7 அளவுருக்கள்**  
பயிற்சி பிழை = 5.3 | பயிற்சி பிழை = 0  
சரிபார்ப்பு பிழை = 5.1 | சரிபார்ப்பு பிழை = 20  

* இடது பக்கம், ஒரு நேர்மையான கோடு அணுகுமுறை உள்ளது. அளவுருக்களின் எண்ணிக்கை போதுமானதாக இருப்பதால், மாடல் புள்ளி விநியோகத்தின் பின்னால் உள்ள கருத்தை சரியாகப் பெறுகிறது.  
* வலது பக்கம், மாடல் மிகவும் சக்திவாய்ந்தது. 5 புள்ளிகள் மட்டுமே உள்ளன, ஆனால் மாடலில் 7 அளவுருக்கள் உள்ளதால், அனைத்து புள்ளிகளையும் கடந்து செல்ல மாடல் சரிசெய்ய முடியும், இதனால் பயிற்சி பிழை 0 ஆகிறது. ஆனால், இது தரவின் சரியான முறைமையைப் புரிந்துகொள்ள மாடலைத் தடுக்கிறது, எனவே சரிபார்ப்பு பிழை மிகவும் அதிகமாக உள்ளது.

மாடலின் செறிவுத்தன்மை (அளவுருக்களின் எண்ணிக்கை) மற்றும் பயிற்சி மாதிரிகளின் எண்ணிக்கைக்கு இடையில் சரியான சமநிலையை அடைவது மிகவும் முக்கியம்.

## ஏன் overfitting ஏற்படுகிறது

  * பயிற்சி தரவின் குறைபாடு  
  * மிகவும் சக்திவாய்ந்த மாடல்  
  * உள்ளீட்டு தரவில் அதிக சத்தம்  

## overfitting-ஐ எப்படி கண்டறிவது

மேலே உள்ள கிராஃபில் காண்பது போல, overfitting-ஐ மிகவும் குறைந்த பயிற்சி பிழை மற்றும் அதிக சரிபார்ப்பு பிழை மூலம் கண்டறியலாம். பொதுவாக பயிற்சியின் போது, பயிற்சி மற்றும் சரிபார்ப்பு பிழைகள் இரண்டும் குறையத் தொடங்கும், பின்னர் ஒரு கட்டத்தில் சரிபார்ப்பு பிழை குறையாமல், அதிகரிக்கத் தொடங்கலாம். இது overfitting-ஐ குறிக்கும், மற்றும் இந்த நேரத்தில் பயிற்சியை நிறுத்த வேண்டும் (அல்லது குறைந்தது மாடலின் ஒரு snapshot-ஐ எடுக்க வேண்டும்).

## overfitting-ஐ எப்படி தடுக்கலாம்

overfitting ஏற்படுவதை நீங்கள் கவனித்தால், நீங்கள் பின்வரும் செயல்களை செய்யலாம்:

 * பயிற்சி தரவின் அளவை அதிகரிக்கவும்  
 * மாடலின் சிக்கல்தன்மையை குறைக்கவும்  
 * Dropout போன்ற சில regularization தொழில்நுட்பங்களை பயன்படுத்தவும், இதை நாம் பின்னர் பார்க்கலாம்.  

## Overfitting மற்றும் Bias-Variance Tradeoff

Overfitting என்பது Bias-Variance Tradeoff எனப்படும் புள்ளியியல் பிரச்சினையின் ஒரு பொதுவான நிலை. மாடலில் பிழையின் சாத்தியமான மூலங்களை நாம் கருதினால், இரண்டு வகையான பிழைகளை காணலாம்:

* **Bias பிழைகள்**: பயிற்சி தரவின் உறவுகளை சரியாகப் பிடிக்க முடியாததனால் ஏற்படும். இது மாடல் போதுமான சக்திவாய்ந்ததாக இல்லாததனால் ஏற்படலாம் (**underfitting**).  
* **Variance பிழைகள்**: மாடல் உள்ளீட்டு தரவின் சத்தத்தை பொருத்துவதால் ஏற்படும் (**overfitting**).  

பயிற்சியின் போது, bias பிழை குறைகிறது (மாடல் தரவுகளை அணுக கற்றுக்கொள்கிறது), மற்றும் variance பிழை அதிகரிக்கிறது. overfitting-ஐ தடுக்க பயிற்சியை நிறுத்துவது - கையேடு முறையில் (overfitting-ஐ கண்டறிந்தால்) அல்லது தானாக (regularization-ஐ அறிமுகப்படுத்துவதன் மூலம்) - முக்கியம்.

## முடிவு

இந்த பாடத்தில், இரண்டு பிரபலமான AI கட்டமைப்புகளான TensorFlow மற்றும் PyTorch-க்கு உள்ள API-களின் வேறுபாடுகளைப் பற்றி கற்றீர்கள். மேலும், ஒரு முக்கியமான தலைப்பு, overfitting பற்றிய தகவல்களையும் கற்றீர்கள்.

## 🚀 சவால்

இணைக்கப்பட்ட நோட்புக்குகளில், 'tasks' கீழே காணப்படும்; நோட்புக்குகளைப் படித்து, பணிகளை முடிக்கவும்.

## மதிப்பீடு மற்றும் சுய கற்றல்

கீழே உள்ள தலைப்புகளில் சில ஆராய்ச்சி செய்யவும்:

- TensorFlow  
- PyTorch  
- Overfitting  

தங்களை பின்வரும் கேள்விகளை கேட்கவும்:

- TensorFlow மற்றும் PyTorch-இன் வேறுபாடு என்ன?  
- Overfitting மற்றும் underfitting-இன் வேறுபாடு என்ன?  

## பணிக்கட்டளை

இந்த ஆய்வகத்தில், PyTorch அல்லது TensorFlow-ஐ பயன்படுத்தி ஒற்றை மற்றும் பல அடுக்குகளைக் கொண்ட முழுமையாக இணைக்கப்பட்ட நெட்வொர்க்குகளைப் பயன்படுத்தி இரண்டு வகைப்படுத்தல் பிரச்சினைகளை தீர்க்க வேண்டும்.

---

**குறிப்பு**:  
இந்த ஆவணம் [Co-op Translator](https://github.com/Azure/co-op-translator) என்ற AI மொழிபெயர்ப்பு சேவையைப் பயன்படுத்தி மொழிபெயர்க்கப்பட்டுள்ளது. நாங்கள் துல்லியத்திற்காக முயற்சிக்கிறோம், ஆனால் தானியக்க மொழிபெயர்ப்புகளில் பிழைகள் அல்லது தவறான தகவல்கள் இருக்கக்கூடும் என்பதை தயவுசெய்து கவனத்தில் கொள்ளுங்கள். அதன் தாய்மொழியில் உள்ள மூல ஆவணம் அதிகாரப்பூர்வ ஆதாரமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பைப் பயன்படுத்துவதால் ஏற்படும் எந்த தவறான புரிதல்கள் அல்லது தவறான விளக்கங்களுக்கு நாங்கள் பொறுப்பல்ல.