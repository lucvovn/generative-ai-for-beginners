<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0135e6c271f3ece8699050d4debbce88",
  "translation_date": "2025-10-17T23:46:46+00:00",
  "source_file": "04-prompt-engineering-fundamentals/README.md",
  "language_code": "tw"
}
-->
# 提示工程基礎

[![提示工程基礎](../../../translated_images/04-lesson-banner.a2c90deba7fedacda69f35b41636a8951ec91c2e33f5420b1254534ac85bc18e.tw.png)](https://youtu.be/GElCu2kUlRs?si=qrXsBvXnCW12epb8)

## 簡介
本模組涵蓋了在生成式 AI 模型中創建有效提示的基本概念和技術。如何向 LLM 撰寫提示非常重要。一個精心設計的提示可以獲得更高品質的回應。但究竟什麼是 _提示_ 和 _提示工程_？如何改善我發送給 LLM 的提示 _輸入_？這些是我們在本章及下一章中試圖回答的問題。

_生成式 AI_ 能夠根據使用者的需求創造新的內容（例如文字、圖片、音頻、程式碼等）。它使用像 OpenAI 的 GPT（"生成預訓練轉換器"）系列這樣的 _大型語言模型_，這些模型專門針對自然語言和程式碼進行訓練。

使用者現在可以通過熟悉的互動方式（例如聊天）與這些模型進行交流，而不需要任何技術專業知識或訓練。這些模型是 _基於提示_ 的——使用者發送文字輸入（提示），並獲得 AI 的回應（完成）。他們可以在多輪對話中反覆與 AI 交流，逐步完善提示，直到回應符合預期。

"提示" 現在成為生成式 AI 應用的主要 _程式介面_，告訴模型該做什麼並影響回應的品質。"提示工程" 是一個快速增長的研究領域，專注於提示的 _設計和優化_，以在大規模應用中提供一致且高品質的回應。

## 學習目標

在本課程中，我們將學習什麼是提示工程、它的重要性，以及如何為特定模型和應用目標設計更有效的提示。我們將了解提示工程的核心概念和最佳實踐，並學習如何在互動式 Jupyter Notebook "沙盒" 環境中應用這些概念到實際例子中。

完成本課程後，我們將能夠：

1. 解釋什麼是提示工程及其重要性。
2. 描述提示的組成部分及其用途。
3. 學習提示工程的最佳實踐和技術。
4. 使用 OpenAI 端點將所學技術應用於實際例子。

## 關鍵術語

提示工程：設計和改進輸入以引導 AI 模型生成期望輸出的實踐。
分詞：將文字轉換為模型可以理解和處理的小單元（稱為 token）的過程。
指令調整 LLM：通過特定指令進行微調以提高回應準確性和相關性的大型語言模型（LLM）。

## 學習沙盒

提示工程目前更像是一門藝術而非科學。提高直覺的最佳方法是 _多加練習_，並採用結合應用領域專業知識、推薦技術和模型特定優化的試錯方法。

本課程附帶的 Jupyter Notebook 提供了一個 _沙盒_ 環境，您可以在學習過程中或課程結尾的程式碼挑戰中嘗試所學內容。要執行練習，您需要：

1. **Azure OpenAI API 金鑰**——已部署 LLM 的服務端點。
2. **Python 執行環境**——用於執行 Notebook。
3. **本地環境變數**——_完成 [SETUP](./../00-course-setup/02-setup-local.md?WT.mc_id=academic-105485-koreyst) 步驟以準備好_。

Notebook 附帶了 _入門_ 練習——但我們鼓勵您添加自己的 _Markdown_（描述）和 _Code_（提示請求）部分，以嘗試更多例子或想法，並建立提示設計的直覺。

## 圖解指南

想在深入學習之前了解本課程的全貌嗎？查看這份圖解指南，它能幫助您了解主要涵蓋的主題以及每個主題的關鍵要點。課程路線圖將帶您從理解核心概念和挑戰到使用相關提示工程技術和最佳實踐來解決這些問題。請注意，指南中的 "進階技術" 部分指的是本課程下一章的內容。

![提示工程圖解指南](../../../translated_images/04-prompt-engineering-sketchnote.d5f33336957a1e4f623b826195c2146ef4cc49974b72fa373de6929b474e8b70.tw.png)

## 我們的初創公司

現在，讓我們談談 _這個主題_ 與我們的初創公司使命 [將 AI 創新帶入教育](https://educationblog.microsoft.com/2023/06/collaborating-to-bring-ai-innovation-to-education?WT.mc_id=academic-105485-koreyst) 的關聯。我們希望建立 AI 驅動的 _個性化學習_ 應用——因此讓我們思考不同的應用使用者如何 "設計" 提示：

- **管理者** 可能要求 AI _分析課程數據以識別覆蓋範圍的缺口_。AI 可以用程式碼總結結果或進行可視化。
- **教育者** 可能要求 AI _為目標受眾和主題生成課程計劃_。AI 可以以指定格式構建個性化計劃。
- **學生** 可能要求 AI _輔導他們學習困難的科目_。AI 現在可以根據學生的水平提供量身定制的課程、提示和例子。

這僅僅是冰山一角。查看 [教育提示](https://github.com/microsoft/prompts-for-edu/tree/main?WT.mc_id=academic-105485-koreyst)——由教育專家策劃的開源提示庫——以更廣泛地了解可能性！_嘗試在沙盒中運行一些提示或使用 OpenAI Playground 看看會發生什麼！_

## 什麼是提示工程？

我們在本課程開始時將 **提示工程** 定義為 _設計和優化_ 文本輸入（提示）的過程，以便為特定應用目標和模型提供一致且高品質的回應（完成）。我們可以將其視為兩步過程：

- 為特定模型和目標 _設計_ 初始提示
- 反覆 _改進_ 提示以提高回應品質

這必然是一個需要使用者直覺和努力的試錯過程，以獲得最佳結果。那麼為什麼它很重要？要回答這個問題，我們首先需要了解三個概念：

- _分詞_ = 模型如何 "看待" 提示
- _基礎 LLM_ = 基礎模型如何 "處理" 提示
- _指令調整 LLM_ = 模型如何現在能 "看到" 任務

### 分詞

LLM 將提示視為 _token 的序列_，不同的模型（或模型版本）可能以不同方式對同一提示進行分詞。由於 LLM 是基於 token 而非原始文本進行訓練的，提示的分詞方式直接影響生成回應的品質。

要了解分詞如何運作，可以嘗試使用 [OpenAI Tokenizer](https://platform.openai.com/tokenizer?WT.mc_id=academic-105485-koreyst) 等工具。將您的提示複製到工具中，看看它如何轉換為 token，注意空白字符和標點符號的處理方式。請注意，此示例顯示的是舊版 LLM（GPT-3）——因此使用較新的模型可能會產生不同的結果。

![分詞](../../../translated_images/04-tokenizer-example.e71f0a0f70356c5c7d80b21e8753a28c18a7f6d4aaa1c4b08e65d17625e85642.tw.png)

### 概念：基礎模型

一旦提示被分詞，["基礎 LLM"](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst)（或基礎模型）的主要功能是預測該序列中的 token。由於 LLM 是基於大量文本數據集進行訓練的，它們對 token 之間的統計關係有很好的理解，並能以一定的信心進行預測。請注意，它們並不理解提示或 token 中單詞的 _含義_；它們只是看到一個模式，並通過下一次預測來 "完成" 該模式。它們可以繼續預測序列，直到使用者干預或達到某些預設條件。

想看看基於提示的完成如何運作嗎？將上述提示輸入 Azure OpenAI Studio 的 [_Chat Playground_](https://oai.azure.com/playground?WT.mc_id=academic-105485-koreyst) 並使用預設設置。系統被配置為將提示視為信息請求——因此您應該看到一個滿足此上下文的完成。

但如果使用者希望看到符合某些標準或任務目標的特定內容呢？這就是 _指令調整_ LLM 的作用。

![基礎 LLM 聊天完成](../../../translated_images/04-playground-chat-base.65b76fcfde0caa6738e41d20f1a6123f9078219e6f91a88ee5ea8014f0469bdf.tw.png)

### 概念：指令調整 LLM

[指令調整 LLM](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) 從基礎模型開始，並通過示例或輸入/輸出對（例如多輪 "消息"）進行微調，這些對可以包含明確的指令——AI 的回應嘗試遵循該指令。

這使用了像人類反饋強化學習（RLHF）這樣的技術，可以訓練模型 _遵循指令_ 並 _從反饋中學習_，以便生成更適合實際應用且更符合使用者目標的回應。

讓我們試試看——重新訪問上述提示，但現在更改 _系統消息_，提供以下指令作為上下文：

> _總結提供的內容，適合二年級學生。結果保持在一段文字內，並包含 3-5 個要點。_

看看結果如何反映所需的目標和格式？教育者現在可以直接將此回應用於該課程的幻燈片中。

![指令調整 LLM 聊天完成](../../../translated_images/04-playground-chat-instructions.b30bbfbdf92f2d051639c9bc23f74a0e2482f8dc7f0dafc6cc6fda81b2b00534.tw.png)

## 為什麼我們需要提示工程？

現在我們知道 LLM 如何處理提示，讓我們來談談 _為什麼_ 我們需要提示工程。答案在於目前的 LLM 存在一些挑戰，這使得在不投入提示構建和優化的努力下，難以實現 _可靠且一致的完成_。例如：

1. **模型回應具有隨機性。** _相同的提示_ 在不同的模型或模型版本中可能會產生不同的回應。甚至在 _相同模型_ 中的不同時間也可能產生不同的結果。_提示工程技術可以幫助我們通過提供更好的防護措施來減少這些變化_。

1. **模型可能會捏造回應。** 模型是基於 _大量但有限_ 的數據集進行預訓練的，這意味著它們對於訓練範圍之外的概念缺乏知識。因此，它們可能生成不準確、虛構或直接與已知事實相矛盾的完成。_提示工程技術幫助使用者識別並減少此類捏造，例如要求 AI 提供引用或推理_。

1. **模型能力會有所不同。** 新的模型或模型版本可能具有更豐富的功能，但也帶來了成本和複雜性方面的獨特問題。_提示工程可以幫助我們開發最佳實踐和工作流程，抽象出差異並以可擴展、無縫的方式適應模型特定需求_。

讓我們在 OpenAI 或 Azure OpenAI Playground 中看看這些情況：

- 使用相同的提示在不同的 LLM 部署（例如 OpenAI、Azure OpenAI、Hugging Face）中運行——您是否看到差異？
- 在 _相同_ 的 LLM 部署（例如 Azure OpenAI Playground）中反覆使用相同的提示——這些變化有什麼不同？

### 捏造的例子

在本課程中，我們使用術語 **"捏造"** 來指代 LLM 有時因其訓練限制或其他約束而生成事實上不正確信息的現象。您可能在流行文章或研究論文中聽過這種現象被稱為 _"幻覺"_。然而，我們強烈建議使用 _"捏造"_ 這個術語，以免因將人類特徵賦予機器驅動的結果而不必要地擬人化這種行為。這也從術語的角度加強了 [負責任的 AI 指南](https://www.microsoft.com/ai/responsible-ai?WT.mc_id=academic-105485-koreyst)，去除可能在某些情境中被認為具有冒犯性或不包容的術語。

想了解捏造如何運作嗎？想出一個指示 AI 為不存在的主題生成內容的提示（以確保它不在訓練數據集中）。例如——我嘗試了以下提示：

> **提示：** 為 2076 年的火星戰爭生成一個課程計劃。
網路搜尋顯示有關火星戰爭的虛構故事（例如電視劇或書籍）——但沒有發生在2076年的。常識告訴我們，2076年是未來的年份，因此不可能與真實事件相關聯。

那麼，當我們使用不同的LLM提供者運行這個提示時會發生什麼？

> **回應1**：OpenAI Playground (GPT-35)

![回應1](../../../translated_images/04-fabrication-oai.5818c4e0b2a2678c40e0793bf873ef4a425350dd0063a183fb8ae02cae63aa0c.tw.png)

> **回應2**：Azure OpenAI Playground (GPT-35)

![回應2](../../../translated_images/04-fabrication-aoai.b14268e9ecf25caf613b7d424c16e2a0dc5b578f8f960c0c04d4fb3a68e6cf61.tw.png)

> **回應3**：Hugging Face Chat Playground (LLama-2)

![回應3](../../../translated_images/04-fabrication-huggingchat.faf82a0a512789565e410568bce1ac911075b943dec59b1ef4080b61723b5bf4.tw.png)

正如預期，每個模型（或模型版本）都因隨機行為和模型能力的差異而產生略有不同的回應。例如，一個模型針對八年級的受眾，而另一個則假設是高中生。但所有三個模型都生成了可能讓不知情的用戶相信事件是真實的回應。

像 _元提示_ 和 _溫度配置_ 這樣的提示工程技術可能在一定程度上減少模型的虛構內容。新的提示工程 _架構_ 也無縫地將新工具和技術整合到提示流程中，以減輕或減少這些影響。

## 案例研究：GitHub Copilot

讓我們通過一個案例研究來了解提示工程在實際解決方案中的應用： [GitHub Copilot](https://github.com/features/copilot?WT.mc_id=academic-105485-koreyst)。

GitHub Copilot 是您的 "AI 配對程式設計師"——它將文字提示轉換為代碼補全，並集成到您的開發環境（例如 Visual Studio Code）中，提供無縫的使用體驗。正如以下系列博客所記錄的那樣，最早的版本基於 OpenAI Codex 模型——工程師很快意識到需要對模型進行微調並開發更好的提示工程技術，以提高代碼質量。在七月，他們 [推出了一個超越 Codex 的改進版 AI 模型](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst)，提供更快速的建議。

按順序閱讀以下文章，了解他們的學習過程。

- **2023年5月** | [GitHub Copilot 正在更好地理解您的代碼](https://github.blog/2023-05-17-how-github-copilot-is-getting-better-at-understanding-your-code/?WT.mc_id=academic-105485-koreyst)
- **2023年5月** | [GitHub內部：與 GitHub Copilot 背後的 LLMs 合作](https://github.blog/2023-05-17-inside-github-working-with-the-llms-behind-github-copilot/?WT.mc_id=academic-105485-koreyst)
- **2023年6月** | [如何為 GitHub Copilot 編寫更好的提示](https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/?WT.mc_id=academic-105485-koreyst)
- **2023年7月** | [GitHub Copilot 使用改進的 AI 模型超越 Codex](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst)
- **2023年7月** | [開發者的提示工程和 LLMs 指南](https://github.blog/2023-07-17-prompt-engineering-guide-generative-ai-llms/?WT.mc_id=academic-105485-koreyst)
- **2023年9月** | [如何構建企業 LLM 應用：來自 GitHub Copilot 的教訓](https://github.blog/2023-09-06-how-to-build-an-enterprise-llm-application-lessons-from-github-copilot/?WT.mc_id=academic-105485-koreyst)

您還可以瀏覽他們的 [工程博客](https://github.blog/category/engineering/?WT.mc_id=academic-105485-koreyst) 以獲取更多像 [這篇文章](https://github.blog/2023-09-27-how-i-used-github-copilot-chat-to-build-a-reactjs-gallery-prototype/?WT.mc_id=academic-105485-koreyst) 的帖子，展示這些模型和技術如何應用於推動實際應用。

---

## 提示構建

我們已經了解了提示工程的重要性——現在讓我們來理解提示是如何 _構建_ 的，以便評估不同的技術，從而設計出更有效的提示。

### 基本提示

讓我們從基本提示開始：向模型發送沒有其他上下文的文字輸入。以下是一個例子——當我們將美國國歌的前幾個字發送到 OpenAI [Completion API](https://platform.openai.com/docs/api-reference/completions?WT.mc_id=academic-105485-koreyst) 時，它會立即用接下來的幾行進行補全，展示了基本的預測行為。

| 提示（輸入）     | 補全（輸出）                                                                                                                        |
| :--------------- | :--------------------------------------------------------------------------------------------------------------------------------- |
| Oh say can you see | 看起來您正在開始唱《星條旗永不落》，這是美國的國歌。完整的歌詞是... |

### 複雜提示

現在讓我們在基本提示中添加上下文和指令。[Chat Completion API](https://learn.microsoft.com/azure/ai-services/openai/how-to/chatgpt?WT.mc_id=academic-105485-koreyst) 允許我們構建一個由 _消息_ 集合組成的複雜提示，其中包括：

- 反映 _用戶_ 輸入和 _助手_ 回應的輸入/輸出對。
- 系統消息設置助手行為或個性化的上下文。

請求現在的形式如下，其中 _分詞_ 有效地捕捉了上下文和對話中的相關信息。現在，改變系統上下文可能對補全的質量產生與提供的用戶輸入同樣重要的影響。

```python
response = openai.chat.completions.create(
    model="gpt-3.5-turbo",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Who won the world series in 2020?"},
        {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
        {"role": "user", "content": "Where was it played?"}
    ]
)
```

### 指令提示

在上述例子中，用戶提示是一個簡單的文字查詢，可以解釋為信息請求。使用 _指令_ 提示，我們可以使用該文字更詳細地指定任務，為AI提供更好的指導。以下是一個例子：

| 提示（輸入）                                                                                                                                                                                                                         | 補全（輸出）                                                                                                        | 指令類型            |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------- | :------------------ |
| 撰寫一段關於南北戰爭的描述                                                                                                                                                                                                   | _返回了一段簡單的段落_                                                                                              | 簡單                |
| 撰寫一段關於南北戰爭的描述。提供關鍵日期和事件並描述其重要性                                                                                                                                     | _返回了一段段落，後面附有關鍵事件日期及描述的列表_                                             | 複雜                |
| 撰寫一段關於南北戰爭的描述，限於一段。提供3個關鍵日期及其重要性的要點。再提供3個關鍵歷史人物及其貢獻的要點。以JSON文件格式返回輸出。 | _返回了更詳細的文本框內容，格式為JSON，您可以複製粘貼到文件中並根據需要進行驗證_ | 複雜。格式化。       |

## 主要內容

在上述例子中，提示仍然相當開放，允許LLM決定其預訓練數據集中哪些部分是相關的。使用 _主要內容_ 設計模式，輸入文字被分為兩部分：

- 指令（行動）
- 相關內容（影響行動）

以下是一個例子，其中指令是“用兩句話總結”。

| 提示（輸入）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 補全（輸出）                                                                                                                                                                                                                                                                             |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 木星是太陽系的第五顆行星，也是太陽系中最大的行星。它是一顆氣體巨星，其質量是太陽的千分之一，但比太陽系中所有其他行星的總和還要大兩倍半。木星是夜空中肉眼可見的最亮天體之一，自有記錄以來就被古代文明所知。它以羅馬神朱庇特命名。[19] 從地球上看，木星的反射光亮度足以投射出可見的陰影，[20] 平均來說，它是夜空中僅次於月亮和金星的第三亮自然天體。 <br/> **用兩句話簡短總結** | 木星是太陽系的第五顆行星，也是最大的行星，夜空中最亮的天體之一。它以羅馬神朱庇特命名，是一顆氣體巨星，其質量比太陽系中所有其他行星的總和還要大兩倍半。 |

主要內容部分可以以多種方式用於推動更有效的指令：

- **範例** - 不直接告訴模型需要做什麼，而是提供一些範例，讓它推斷出所需的模式。
- **提示** - 在指令後提供一個“提示”，引導模型生成更相關的回應。
- **模板** - 這些是可重複使用的提示“配方”，包含佔位符（變數），可以根據特定用例用數據進行自定義。

讓我們來看看這些技術的實際應用。

### 使用範例

這是一種方法，您可以使用主要內容“餵給模型”一些所需輸出的範例，讓它推斷出所需輸出的模式。根據提供的範例數量，我們可以有零次提示、一次提示、少量提示等。

提示現在由三個部分組成：

- 任務描述
- 所需輸出的幾個範例
- 新範例的開始（成為隱含的任務描述）

| 學習類型 | 提示（輸入）                                                                                                                                        | 補全（輸出）         |
| :------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------ |
| 零次提示 | "The Sun is Shining". 翻譯成西班牙語                                                                                                            | "El Sol está brillando".    |
| 一次提示 | "The Sun is Shining" => ""El Sol está brillando". <br> "It's a Cold and Windy Day" =>                                                                 | "Es un día frío y ventoso". |
| 少量提示 | The player ran the bases => Baseball <br/> The player hit an ace => Tennis <br/> The player hit a six => Cricket <br/> The player made a slam-dunk => | Basketball                  |
|          |                                                                                                                                                       |                             |

注意在零次提示中，我們必須提供明確的指令（“翻譯成西班牙語”），但在一次提示中它被推斷出來了。少量提示的例子顯示，添加更多範例可以讓模型在沒有額外指令的情況下做出更準確的推斷。

### 提示線索

使用主要內容的另一種技術是提供 _線索_ 而不是範例。在這種情況下，我們通過 _開始_ 一段反映所需回應格式的片段來“引導”模型。然後模型“接收線索”，以相同的方式繼續。

| 線索數量 | 提示（輸入）                                                                                                                                                                                                                                                                                                                                                                                                                                               | 補全（輸出）                                                                                                                                                                                                                                                                                       |
| :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0        | 木星是太陽系的第五顆行星，也是太陽系中最大的行星。它是一顆氣體巨星，其質量是太陽的千分之一，但比太陽系中所有其他行星的總和還要大兩倍半。木星是夜空中肉眼可見的最亮天體之一，自有記錄以來就被古代文明所知。 <br/>**總結此內容**                                       | 木星是太陽系中最大的行星，也是第五顆行星。它是一顆氣體巨星，其質量是太陽的千分之一，但比其他行星的總和還要大兩倍半。古代文明早已知曉木星，它在夜空中非常明亮。 |
| 1              | 木星是距離太陽第五顆行星，也是太陽系中最大的行星。它是一顆氣體巨星，質量僅為太陽的千分之一，但卻是太陽系中其他所有行星質量總和的兩倍半。木星是夜空中肉眼可見最亮的天體之一，自古以來就被古代文明所知。<br/>**摘要**<br/>我們了解到木星 | 是距離太陽第五顆行星，也是太陽系中最大的行星。它是一顆氣體巨星，質量僅為太陽的千分之一，但卻是其他所有行星質量總和的兩倍半。它可以輕易用肉眼看到，自古以來就被人類所知。 |
| 2              | 木星是距離太陽第五顆行星，也是太陽系中最大的行星。它是一顆氣體巨星，質量僅為太陽的千分之一，但卻是太陽系中其他所有行星質量總和的兩倍半。木星是夜空中肉眼可見最亮的天體之一，自古以來就被古代文明所知。<br/>**摘要**<br/>我們學到的三個主要事實： | 1. 木星是距離太陽第五顆行星，也是太陽系中最大的行星。<br/> 2. 它是一顆氣體巨星，質量僅為太陽的千分之一...<br/> 3. 木星自古以來就可以用肉眼看到... |
|                |                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                           |

### 提示模板

提示模板是一種_預定義的提示配方_，可以根據需要存儲並重複使用，以在大規模應用中提供更一致的用戶體驗。最簡單的形式是像[OpenAI的這個例子](https://platform.openai.com/examples?WT.mc_id=academic-105485-koreyst)一樣，提供交互式提示組件（用戶和系統消息）以及基於API的請求格式——支持重複使用。

更複雜的形式如[LangChain的這個例子](https://python.langchain.com/docs/concepts/prompt_templates/?WT.mc_id=academic-105485-koreyst)，它包含_佔位符_，可以用來自多種來源（用戶輸入、系統上下文、外部數據源等）的數據替換，以動態生成提示。這使我們能夠創建可重複使用的提示庫，用於以程式化方式在大規模應用中提供一致的用戶體驗。

最後，模板的真正價值在於能夠創建和發布_提示庫_，針對垂直應用領域進行優化——提示模板現在被_優化_以反映應用特定的上下文或示例，使響應對目標用戶群體更相關和準確。[Prompts For Edu](https://github.com/microsoft/prompts-for-edu?WT.mc_id=academic-105485-koreyst)存儲庫是一個很好的例子，為教育領域策劃了一個提示庫，重點放在課程規劃、課程設計、學生輔導等關鍵目標上。

## 支援內容

如果我們將提示構建視為包含指令（任務）和目標（主要內容），那麼_次要內容_就像是我們提供的額外上下文，用來**以某種方式影響輸出**。它可以是調整參數、格式指令、主題分類等，幫助模型_定制_其響應以符合所需的用戶目標或期望。

例如：給定一個課程目錄，其中包含所有課程的詳細元數據（名稱、描述、級別、元數據標籤、講師等）：

- 我們可以定義一個指令來“總結2023年秋季課程目錄”
- 我們可以使用主要內容提供一些所需輸出的示例
- 我們可以使用次要內容來識別最感興趣的5個“標籤”。

現在，模型可以按照示例中顯示的格式提供摘要——但如果結果有多個標籤，它可以優先考慮次要內容中識別的5個標籤。

---

<!--
課程模板：
本單元應涵蓋核心概念#1。
用示例和參考來加強概念。

概念#3：
提示工程技術。
提示工程有哪些基本技術？
用一些練習來說明。
-->

## 提示設計最佳實踐

現在我們知道了如何_構建_提示，我們可以開始思考如何_設計_它們以反映最佳實踐。我們可以分為兩部分來考慮——擁有正確的_心態_和應用正確的_技術_。

### 提示工程心態

提示工程是一個反覆試驗的過程，因此請記住三個廣泛的指導因素：

1. **領域知識很重要。** 響應的準確性和相關性取決於應用或用戶所處的_領域_。運用你的直覺和領域專業知識進一步**定制技術**。例如，在系統提示中定義_領域特定的個性_，或在用戶提示中使用_領域特定的模板_。提供反映領域特定上下文的次要內容，或使用_領域特定的線索和示例_引導模型進入熟悉的使用模式。

2. **模型理解很重要。** 我們知道模型本質上是隨機的。但模型的實現也可能因其使用的訓練數據集（預訓練知識）、提供的功能（例如通過API或SDK）以及其優化的內容類型（例如代碼、圖像或文本）而有所不同。了解你使用的模型的優勢和局限性，並利用這些知識來_優先處理任務_或構建_定制模板_，以優化模型的能力。

3. **迭代和驗證很重要。** 模型正在快速發展，提示工程技術也在不斷進步。作為領域專家，你可能擁有其他上下文或標準，這些可能不適用於更廣泛的社群。使用提示工程工具和技術來“快速啟動”提示構建，然後使用自己的直覺和領域專業知識進行迭代和驗證。記錄你的見解並創建一個**知識庫**（例如提示庫），供其他人用作新的基準，以便未來更快地迭代。

## 最佳實踐

現在讓我們來看看[OpenAI](https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api?WT.mc_id=academic-105485-koreyst)和[Azure OpenAI](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering#best-practices?WT.mc_id=academic-105485-koreyst)專家推薦的一些常見最佳實踐。

| 內容                              | 原因                                                                                                                                                                                                                                               |
| :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 評估最新模型。                   | 新一代模型可能具有改進的功能和質量——但也可能導致更高的成本。評估它們的影響，然後做出遷移決策。                                                                                                                                                |
| 分離指令和上下文。               | 檢查你的模型/提供者是否定義了_分隔符_，以更清楚地區分指令、主要和次要內容。這可以幫助模型更準確地分配權重給標記。                                                                                     |
| 明確具體。                       | 提供更多關於所需上下文、結果、長度、格式、風格等的細節。這將提高響應的質量和一致性。將配方捕捉到可重複使用的模板中。                                                                                      |
| 描述性，使用示例。               | 模型可能對“展示和講解”方法反應更好。從`零樣本`方法開始，給它一個指令（但沒有示例），然後嘗試`少樣本`作為改進，提供一些所需輸出的示例。使用類比。                                                   |
| 使用線索啟動完成。               | 通過給它一些引導詞或短語來引導它達到所需的結果，這些詞或短語可以作為響應的起點。                                                                                                                           |
| 重複強調。                       | 有時你可能需要對模型重複指令。在主要內容之前和之後給出指令，使用指令和線索等。迭代和驗證以查看效果。                                                                                                     |
| 順序很重要。                     | 向模型呈現信息的順序可能會影響輸出，即使是在學習示例中，由於最近性偏差。嘗試不同的選項以查看效果最佳的方式。                                                                                           |
| 給模型一個“退出”選項。           | 如果模型因某些原因無法完成任務，請給它一個_備選_的完成響應。這可以減少模型生成錯誤或虛假響應的可能性。                                                                                                 |
|                                   |                                                                                                                                                                                                                                                   |

與任何最佳實踐一樣，請記住，_你的效果可能會有所不同_，這取決於模型、任務和領域。以此為起點，並進行迭代以找到最適合你的方法。隨著新模型和工具的推出，持續重新評估你的提示工程過程，重點放在過程的可擴展性和響應質量上。

<!--
課程模板：
本單元應提供代碼挑戰（如果適用）

挑戰：
鏈接到一個Jupyter Notebook，其中只有代碼註釋作為指令（代碼部分是空的）。

解決方案：
鏈接到一個填寫並運行提示的Notebook副本，顯示一個示例。
-->

## 作業

恭喜！你完成了本課程！現在是時候用真實的例子來測試一些概念和技術了！

在作業中，我們將使用一個Jupyter Notebook進行互動式練習。你也可以擴展Notebook，添加自己的Markdown和代碼單元格來探索自己的想法和技術。

### 開始之前，請fork這個repo，然後

- （推薦）啟動GitHub Codespaces
- （或者）將repo克隆到你的本地設備並使用Docker Desktop
- （或者）使用你喜歡的Notebook運行環境打開Notebook。

### 接下來，配置你的環境變數

- 將repo根目錄中的`.env.copy`文件複製到`.env`，並填寫`AZURE_OPENAI_API_KEY`、`AZURE_OPENAI_ENDPOINT`和`AZURE_OPENAI_DEPLOYMENT`的值。回到[學習沙盒部分](../../../04-prompt-engineering-fundamentals/04-prompt-engineering-fundamentals)了解如何操作。

### 接下來，打開Jupyter Notebook

- 選擇運行時內核。如果使用選項1或2，只需選擇開發容器提供的默認Python 3.10.x內核。

你已準備好運行練習。請注意，這裡沒有_正確或錯誤_的答案——只是通過反覆試驗探索選項，並建立對於特定模型和應用領域有效的直覺。

_因此，本課程中沒有代碼解決方案部分。相反，Notebook將有標題為“我的解決方案”的Markdown單元格，顯示一個示例輸出供參考。_

 <!--
課程模板：
用摘要和自學資源來結束本節。
-->

## 知識檢查

以下哪一個提示符合合理的最佳實踐？

1. 給我看一輛紅色的車
2. 給我看一輛紅色的沃爾沃XC90型汽車，停在懸崖邊，夕陽西下
3. 給我看一輛紅色的沃爾沃XC90型汽車

A: 2，這是最好的提示，因為它提供了“什麼”的細節，並進一步具體化（不僅僅是任何車，而是特定的品牌和型號），它還描述了整體場景。3是次佳選擇，因為它也包含了很多描述。

## 🚀 挑戰

試著利用“線索”技術完成以下提示：完成句子“給我看一輛紅色的沃爾沃型號是”。它的響應是什麼？你會如何改進？

## 出色的工作！繼續學習

想了解更多不同的提示工程概念嗎？請訪問[持續學習頁面](https://aka.ms/genai-collection?WT.mc_id=academic-105485-koreyst)，找到其他關於此主題的精彩資源。

前往第5課，我們將探討[高級提示技術](../05-advanced-prompts/README.md?WT.mc_id=academic-105485-koreyst)！

---

**免責聲明**：  
本文件已使用 AI 翻譯服務 [Co-op Translator](https://github.com/Azure/co-op-translator) 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。